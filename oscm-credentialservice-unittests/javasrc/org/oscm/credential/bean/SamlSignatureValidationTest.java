/*******************************************************************************
 *  Copyright FUJITSU LIMITED 2016 
 *******************************************************************************/

package org.oscm.credential.bean;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.security.PrivateKey;
import java.security.PublicKey;

import org.junit.Before;
import org.junit.Test;

import org.oscm.credential.bean.SamlServiceBean.ResponseBuilder;
import org.oscm.saml.api.KeyLoader;
import org.oscm.saml.api.KeyLoader.Algorithm;
import org.oscm.saml.api.Response;
import org.oscm.saml.sp.MockKeyProvider;
import org.oscm.saml.sp.ResponseValidator;

/**
 * Test the digital signing of the SAML response generated by the
 * BES-IdentityProvider
 * 
 * @author barzu
 */
public class SamlSignatureValidationTest {

    private static final String REQUEST_ID = "4040406c-1530-11e0-e869-0110283fdfd0";
    private static final String USER_ID = "admin";

    private static final String WRONG_PUBLIC_KEY = "wrong_pub-key.der";
    private static final String WRONG_PRIVATE_KEY = "wrong_cakey.der";
    private static final long ASSERTION_EXPIRATION = 1800000L;
    private static final long ASSERTION_VALIDITY_TOLERANCE = 600000L;

    private String unsignedResponse;

    @Before
    public void init() throws Exception {
        ResponseBuilder builder = new ResponseBuilder(ASSERTION_EXPIRATION,
                ASSERTION_VALIDITY_TOLERANCE);
        Response createdResponse = builder.createReponse(REQUEST_ID, USER_ID);
        unsignedResponse = createdResponse.toXML().toString();
    }

    @Test
    public void testRightPublicAndPrivateKey() throws Exception {
        // given
        String signedResponse = SamlServiceBean.signSamlResponse(
                unsignedResponse, MockKeyProvider.getPrivateKey(),
                MockKeyProvider.getPublicCertificate());

        // when
        boolean isSigned = ResponseValidator.hasValidSignature(signedResponse,
                MockKeyProvider.getPublicKey());

        // then
        assertTrue("Public and private keys do not match", isSigned);
    }

    @Test
    public void testWrongPublicKey() throws Exception {
        String signedResponse = SamlServiceBean.signSamlResponse(
                unsignedResponse, MockKeyProvider.getPrivateKey(), null);
        PublicKey publicKey = KeyLoader.getPublicKey(getClass(),
                WRONG_PUBLIC_KEY, Algorithm.RSA);
        assertFalse("Invalid public key",
                ResponseValidator.hasValidSignature(signedResponse, publicKey));
    }

    @Test
    public void testWrongPrivateKey() throws Exception {
        PrivateKey privateKey = KeyLoader.getPrivateKey(getClass(),
                WRONG_PRIVATE_KEY, Algorithm.RSA);
        String signedResponse = SamlServiceBean.signSamlResponse(
                unsignedResponse, privateKey, null);
        assertFalse("Invalid private key", ResponseValidator.hasValidSignature(
                signedResponse, MockKeyProvider.getPublicKey()));
    }

}
